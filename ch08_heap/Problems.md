# Prob.1
가질 수 있다.

# Prob.2
아니다.

# Prob.3
리프들의 갯수를 세면 된다.  
꽉 차있는 깊이 = [log2(n+1)]  
가장 깊은 곳에 있는 원소 수 = n - (2^[log2(n+1)]-1)  
리프의 수  
 = n - (2^[log2(n+1)]-1) + 2^([log2(n+1)]-1) - [(n - (2^[log2(n+1)]-1))/2]  
 = n - 2^([log2(n+1)]-1) + 1 - [(n - (2^[log2(n+1)]-1))/2]
  
OR  
  
n = 1 일 때 1개  
n = 2 일 때 1개  
n = 3 일 때 2개  
n = 4 일 때 2개  
n = 5 일 때 3개  
n = 6 일 때 3개  
n = 7 일 때 4개  
n = 8 일 때 4개  
  
n이 홀수 일 때에는 리프가 아닌 모든 노드에 자식이 2 개 씩 있다.  
따라서 노드가 한 개 추가되어도 리프의 개수는 동일하다.  
반면 n이 짝수 일 때에는 마지막 리프의 부모는 자식이 1 개 밖에 없다.  
따라서 노드가 한 개 추가되면 리프가 한 개 늘어난다.  
따라서 리프의 개수는 [n+1/2]개 이다.  

# Prob.4
최악의 경우 : 가장 깊은 곳까지 스며내려야 하므로 총 [log2(n)]번의 비교 필요. 따라서 Theta(logn)이다.  
최선의 경우 : 한 번만 비교하고 끝날 수 있으므로 Theta(1).

# Prob.5
가장 마지막 인덱스의 원소를 삭제하면 되므로 간단한 일이다.
가장 작은 원소를 삭제하고 싶은 것이라면 리프들을 모두 비교해야 한다.

# Prob.6
최선의 경우
```
루트는 스며오르기를 할 필요가 없고, 두 번째 원소부터 스며오르기를 하면 된다.
총 n-1번의 스며오르기가 모두 한 번에 끝난다면, Omega(n)
```
최악의 경우
```
m번째 줄이 꽉 차있는 경우, 해당 줄의 원소들을 스며오르기 시키는 데 걸리는 시간은, 2^(m-1) * (m-1)에 비례한다.
m = 2부터 m = M까지 이를 더하면,
1 * 2^1 + 2* 2^2 + ... + (M-1) * 2^(M-1)
= (2^1 + 2^2 + ... + 2^(M-1)) + (2^2 + ... + 2^(M-1)) + ... + 2^(M-1)
= (2^M - 1) + (2^M - 2) + ... + (2^M - 2^(M-1))
= M * 2^M - (2^M - 1)

M = [log2(n+1)]을 대입하면, 알고리즘의 수행시간은 Theta(nlogn)이 된다.
```
따라서 더 비효율적이다.  
스며내리기 방식을 사용하면 수행시간이 오래걸리는 스며내리기는 루트 근처에서 조금만 수행하고, 갯수가 많은 리프 근처에서는 단계수가 아주 적은 스며내리기를 수행한다.  
반면 스며오르기의 경우 리프에 가까워질수록 수행시간이 오래걸리기 때문에 더 많은 원소에 대해 수행시간이 오래걸리는 작업을 해야 하고, 이런 결과가 나타난다. (많은 거 * 많은 거)

# Prob. 7
값이 증가했기 때문에, 해당 원소의 자식들은 해당 원소보다 더 값이 작음이 확실하다.  
따라서 부모들만 수선해주면 된다.  
```
enlarged(i):
    percolateUp(i);
```
percolateUp은 최대 트리의 높이에 비례하는 시간이 소요되므로, O(logn)의 수행 시간이 걸린다.
