# Prob.1 ~ 3
## 1) 선택 정렬
비교 횟수가 작업 시간을 결정한다.  
최악의 경우와 최선의 경우가 없이 항상 같은 작업이 필요하다.  
최악의 경우 : O(n^2) and Omega(n^2) (i.e. O(n^2))  
최선의 경우 : Theta(n^2)
## 2) 버블 정렬
비교 횟수가 작업 시간을 결정한다.  
태그를 둔 경우로 가정하면,  
최악의 경우는 태그에 걸리는 경우가 없는 경우로, O(n^2) and Omega(n^2) (i.e. O(n^2))  
최선의 경우는 첫 번째에 태그에 걸리는 경우로, n-1번만 비교를 하면 된다. Theta(n)
## 3) 삽입 정렬
비교 횟수가 작업 시간을 결정한다.  
최악의 경우는 배열이 역순으로 정렬되어 있는 경우로, O(n^2) and Omega(n^2) (i.e. O(n^2))  
최선의 경우는 배열이 이미 정렬되어 있는 경우로, n-1번만 비교를 하면 된다. Theta(n)
## 4) 병합 정렬
원소를 옮기는 작업이 작업 시간을 결정한다.  
책의 증명을 참고하면, 최악, 최선의 경우 모두 Theta(nlogn)
## 5) 퀵 정렬
최악의 경우는 배열이 이미 정렬되어 있거나 역순으로 정렬되어 있는 경우이다. (분할이 항상 최악의 경우를 만난다.)  
이 경우, O(n^2) and Omega(n^2) (i.e. O(n^2))  
최선의 경우는 배열이 항상 절반으로 나누어지는 경우이다.  
길이 n인 배열에 대해 분할을 수행하는 데 걸리는 시간은 n에 비례한다.  
T(n) = cn + 2T(n/2)  
n = 2^k를 넣어보면, T(n) = 2^kT(1) + kcn임을 알 수 있다.  
따라서 Theta(nlogn)
## 6) 힙 정렬
최악의 경우는 스며내리기가 항상 끝까지 가는 경우이다.  
각 스며내리기는 log(n)에 비례한다.  
Sigma(log(n))은 n이 큰 경우 integral(log(n))으로 근사하면 Theta(nlogn - n) = Theta(nlogn)  
최선의 경우는 이미 정렬된 상태로, 스며내리기가 항상 첫 번째에 끝난다.  
이 경우, Theta(n)
# Prob.4
## 1) 선택 정렬
Theta(n^2)
## 2) 버블 정렬
Theta(n^2)  
Why..?
## 3) 삽입 정렬
Theta(n^2)  
$E[T(n)] = \textstyle \sum_{k=1}^n frac1n k + E[T(n-1)]$
$ = Theta(n) + E[T(n-1)]$
## 4) 병합 정렬
Theta(nlogn)

#