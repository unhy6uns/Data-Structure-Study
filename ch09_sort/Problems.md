# Prob.1 ~ 3
## 1) 선택 정렬
비교 횟수가 작업 시간을 결정한다.  
최악의 경우와 최선의 경우가 없이 항상 같은 작업이 필요하다.  
최악의 경우 : O(n^2) and Omega(n^2) (i.e. O(n^2))  
최선의 경우 : Theta(n^2)
## 2) 버블 정렬
비교 횟수가 작업 시간을 결정한다.  
태그를 둔 경우로 가정하면,  
최악의 경우는 태그에 걸리는 경우가 없는 경우로, O(n^2) and Omega(n^2) (i.e. O(n^2))  
최선의 경우는 첫 번째에 태그에 걸리는 경우로, n-1번만 비교를 하면 된다. Theta(n)
## 3) 삽입 정렬
비교 횟수가 작업 시간을 결정한다.  
최악의 경우는 배열이 역순으로 정렬되어 있는 경우로, O(n^2) and Omega(n^2) (i.e. O(n^2))  
최선의 경우는 배열이 이미 정렬되어 있는 경우로, n-1번만 비교를 하면 된다. Theta(n)
## 4) 병합 정렬
원소를 옮기는 작업이 작업 시간을 결정한다.  
책의 증명을 참고하면, 최악, 최선의 경우 모두 Theta(nlogn)
## 5) 퀵 정렬
최악의 경우는 배열이 이미 정렬되어 있거나 역순으로 정렬되어 있는 경우이다. (분할이 항상 최악의 경우를 만난다.)  
이 경우, O(n^2) and Omega(n^2) (i.e. O(n^2))  
최선의 경우는 배열이 항상 절반으로 나누어지는 경우이다.  
길이 n인 배열에 대해 분할을 수행하는 데 걸리는 시간은 n에 비례한다.  
T(n) = cn + 2T(n/2)  
n = 2^k를 넣어보면, T(n) = 2^kT(1) + kcn임을 알 수 있다.  
따라서 Theta(nlogn)
## 6) 힙 정렬
최악의 경우는 스며내리기가 항상 끝까지 가는 경우이다.  
각 스며내리기는 log(n)에 비례한다.  
Sigma(log(n))은 n이 큰 경우 integral(log(n))으로 근사하면 Theta(nlogn - n) = Theta(nlogn)  
최선의 경우는 이미 정렬된 상태로, 스며내리기가 항상 첫 번째에 끝난다.  
이 경우, Theta(n)
# Prob.4
## 1) 선택 정렬
Theta(n^2)
## 2) 버블 정렬
Theta(n^2)  
Why..?
## 3) 삽입 정렬
Theta(n^2)  
proof.
$E[T(n)] = \displaystyle \sum_{k=1}^n \frac{1}{n} k + E[T(n-1)]$  
$= \Theta(n) + E[T(n-1)]$  

## 4) 병합 정렬
Theta(nlogn)

# Prob.5
## 1) 선택 정렬
12 70 30 20 55 25  
12 25 30 20 55 70  
..(변화 없는 단계)  
12 25 20 30 55 70  
12 20 25 30 55 70  
..
## 2) 버블 정렬
12 70 30 20 55 25  
12 30 70 20 55 25  
12 30 20 70 55 25  
12 30 20 55 70 25  
12 30 20 55 25 70  
..  
12 20 30 55 25 70  
..  
12 20 30 25 55 70  
..  
..  
12 20 25 30 55 70  
..  
..  
..  
태그에 걸려 종료
## 3) 삽입 정렬
12  
12 70  
12 30 70  
12 20 30 70  
12 20 30 55 70  
12 20 25 30 55 70
# Prob.6
## 1) 병합 정렬
(12 30 20 25 40) /50/ (70 55)  
(12 30 20 25) /40/ /50/ /55/ (70)  
(12 20) /25/ (30) /40/ /50/ /55/ (70)
## 2) 힙 정렬
```
12  70  20  50
        55
    30  25
        40
```
build heap
```
70  55  50  20
        12
    40  25
        30
```
sort
```
20  55  50  (70)
        12
    40  25
        30
```
perlocate down(앞으로는 생략)
```
55  50  20  (70)
        12
    40  25
        30
```
```
20  50  (55)    (70)
        12
    40  25
        30
```
```
40  20  (55)    (70)
        (50)
    30  25
        12
```
```
30  20  (55)    (70)
        (50)
    25  (40)
        12
```
```
25  20  (55)    (70)
        (50)
    12  (40)
        (30)
```
```
20  (25)(55)    (70)
        (50)
    12  (40)
        (30)
```
```
20  (25)(55)(70)
        (50)
    (20)(40)
        (30)
```
# Prob.7
## 퀵 정렬 - partition(A, 0, 7)
각 구역을 /로 구분  
///12 70 30 20 55 25 40/50/  
/12//70 30 20 55 25 40/50/  
/12/70/30 20 55 25 40/50/  
/12 30/70/20 55 25 40/50/  
/12 30 20/70/55 25 40/50/  
/12 30 20/70 55/25 40/50/  
/12 30 20 25/55 70/40/50/
/12 30 20 25 40/70 55/50/  
/12 30 20 25 40/50/55 70//
## 퀵 정렬 - 전체 과정
12 30 20 25 40에 대해 호출
-> /12 30 20 25/40///
  
12 30 20 25에 대해 호출  
-> /12 20/25/30//  
  
12 20에 대해 호출  
-> 12/20///  
    
55 70에 대해 호출  
-> /55/70///

# Prob.8, 9
선택 정렬 - 비효율적  
버블 정렬 - 태그가 있는 경우 n번의 비교만으로 끝난다.  
삽입 정렬 - n번의 비교만으로 끝난다.  
병합 정렬 - 최선의 경우이지만 nlogn의 시간이 걸린다.  
퀵 정렬 - 정렬된 경우가 최악이다.
힙 정렬 - 정렬된 경우 buildheap에서 역순으로 힙을 만들어야 한다. 여기서 이미 nlogn의 시간이 걸린다.  
가장 효율적인 것은 삽입 정렬이다. (완전히 정렬된 경우 버블 정렬이랑 거의 똑같지만 거의 정렬된 배열인 경우에는 삽입 정렬이 유리)  
이미 정렬된 경우에 비효율적인 것은 선택 정렬, 퀵 정렬, 힙 정렬

# Prob. 10
## 1) 선택 정렬
역순이어도 마찬가지로 Theta(n^2)  
## 2) 버블 정렬
역순인 경우 태그에 걸리지 않는다. Theta(n^2)
## 3) 삽입 정렬
역순인 경우가 최악의 경우이다. 모든 비교를 다 해야 한다. Theta(n^2)
## 4) 병합 정렬
역순인 경우 원소를 옮기는 횟수가 가장 많다.  
그러나 항상 Theta(nlogn)
## 5) 퀵 정렬
역순인 경우 마지막 원소가 항상 첫 번째 원소가 되기 때문에, 분할이 잘 일어나지 않아 Theta(n^2)이 걸린다.

# Prob. 11
## 1) 가장 큰 원소 찾기
아무리 적게 비교해도 n-1번의 비교가 필요하므로, O(n)
## 2) 가장 큰 원소와 작은 원소를 동시에 찾기
```
int max <- A[0];
int min <- A[0];
for i <- from 1 to n
    if max<A[i]
        max <- A[i];
    if min>A[i]
        min <- A[i];
```
위의 알고리즘을 이용하면 n에 비례하는 시간이 든다.  
가장 큰 원소 찾기에 O(n)의 시간이 필요함은 증명되어 있으므로, 가장 큰 원소와 작은 원소를 동시에 찾기는 이보다는 크거나 같은 시간이 필요하다.  
따라서 O(n).

# Prob. 12
자리를 빠르게 찾더라도, 좌시프트가 필요하므로 점근적 복잡도는 동일하다. 상수시간 정도는 줄일 수 있을 듯?

# Prob. 13
마지막 정렬 결과에서 첫 번째 자리에 대해서만 정렬이 되어있고 나머지 자리에 대해서는 정렬이 되지 않을 수 있다.

# Prob. 14
동일한 원소가 있을 때 순서가 역전되는지 그대로 유지되는지 확인해보면 된다.  
## 선택 정렬
int theLargest(int last) 메소드를 보면 동일한 원소 중 가장 앞에있는 것의 값이 리턴된다.  
따라서 가장 앞에있는 것이 맨 뒤로 가고, 그 다음 것이 두 번째로 뒤로 가는 식으로 되어 순서가 역전된다.  
따라서 안정성을 유지하지 못한다.
## 버블 정렬
두 원소가 동일할 때에는 swap이 일어나지 않으므로, 순서가 유지된다.  
따라서 안정성을 유지한다.
## 삽입 정렬
newItem이 A[loc]보다 작아질 때 삽입이 일어난다.  
뒤쪽에 동일한 원소가 있는 경우 기존의 원소의 앞쪽에 삽입되므로 순서가 역전된다.  
따라서 안정성을 유지하지 못한다.
## 병합 정렬
분할 과정에서 순서가 유지되므로, 안정성을 유지한다.
## 퀵 정렬
기준원소보다 큰 수들을 모아두는 과정에서 안정성이 깨진다.  
ex)  
일의 자리를 기준으로 정렬된 상태를 다음과 같다고 하자.  
11 21 31 32 12 22 33 13 23  
십의 자리를 기준으로 정렬하면,  
11 / / 21 31 32 12 22 33 13 / 23  
11 21 / / 31 32 12 22 33 13 / 23  
11 21 / 31 / 32 12 22 33 13 / 23  
11 21 / 31 32 / 12 22 33 13 / 23  
11 21 12 / 32 31 / 22 33 13 / 23 <- 여기서 안정성이 깨지기 시작  
11 21 12 22 / 31 32 / 33 13 / 23  
11 21 12 22 / 31 32 33 / 13 / 23  
11 21 12 22 13 / 32 33 31 / / 23

## 힙 정렬
스며내리기가 안정성을 보장하지 않는다.  
일의 자리가 정렬된 상태를 다음과 같다고 하자.  
```
11  21  12
        23
    22  13
```
십의 자리를 기준으로 정렬하면,  
build heap :  
두 child가 동등할 때에는 left child가 선택된다. (안정성 유지)  
부모와 자식이 동등할 때에는 swap이 일어나지 않는다. (안정성 유지)  
```
21  23  12
        11
    22  13
```
그러나 최초 트리의 구조로 인해 안정성이 깨지게 된다.  
순차적인 perlocation down 과정에서도 21부터 마지막에 넣기 때문에 역순으로 정렬이 변한다.  
```
23  13  12
        11
    22  21
```
```
22  13  12
        23
    11  21
```
```
12  13  22
        23
    11  21
```
## 기수 정렬
기수 정렬은 안정성을 유지하는 정렬의 반복이므로 안정성이 유지된다.  
## 계수 정렬
역순으로 B를 채워나가면 안정성이 유지된다.

# Prob. 15
```
public int[] countingSort(int K) {
    int[] cnt = new int[2*K-1];
    for(int i=0; i<K; i++)
        cnt[i] = 0;
    for(int i=0; i<A.length; i++)
        cnt[A[i]+K-1]++;
    cnt[0]--;
    for(int i=1; i<K; i++)
        cnt[i] += cnt[i-1];
    for(int j=A.length-1; j>=0; j--){
        B[cnt[A[j]+K-1]] = A[j];
        cnt[A[j]+K-1]--;
    }
    return B;
}
```
# Prob. 16
본문의 prepare()에서 0~1000 사이의 정수로 구성된 임의의 배열을 생성한다.  
따라서 N=10e5, 10e7인 경우에는 중복되는 원소들이 평균 10개, 100개 정도 생성되었을 것이다.
이러한 경우, 퀵 정렬이 무의미한 정렬을 중복된 원소의 개수만큼 수행하게 된다.  
N=10e5인 경우, 전체 작업 중 1/10이 유의미한 작업이고, N=10e7인 경우 1/100이다.  
이를 고려해보면 유의미한 작업 시간은 퀵 정렬이 훨씬 빠르다.  
두 번째 퀵 정렬의 경우 이미 정렬된 배열에 대해 정렬 작업을 하게 된다.  
이러한 경우 퀵 정렬은 최악의 성능을 보인다.

# Prob. 17
bool형 변수 divider를 이용해 동일한 원소들을 균일하게 나눠주면 된다.
```
partition(A[],p,r):
    divider <- true
    x <- A[r]
    i <- p-1
    for j<- p to r-1
        if(A[j] < x)
            A[++i] <-> A[j]
        else if(A[j] == x)
            if(divider)
                A[++i] <-> A[j]
                divider = !divider
            else
                divider = !divider
    A[i+1] <-> A[r]
    return i+1
```

# Prob. 18


# Prob. 19
```
public void mSort(int p, int r, int[] A, int[] B){
    if (p<r) {
        int q = (q+r)/2;
        mSort(p,q,A,B);     // A 배열을 기준으로 merge
        mSort(q+1,r,A,B);
        merge(p,q,r,B,A);   // B를 merge해서 A에 저장
    }

}